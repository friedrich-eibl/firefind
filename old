(() => {
  // Create the label once
  const label = document.createElement('div');
  label.id = 'hover-tag-label';
  document.documentElement.appendChild(label);

  let raf = null;
  let lastTag = '';
  let pending = null;

  const clamp = (val, min, max) => Math.min(Math.max(val, min), max);

  function findElementFromEvent(e) {
    // Prefer composedPath for Shadow DOM; fall back to target
    if (typeof e.composedPath === 'function') {
      const path = e.composedPath();
      for (const node of path) {
        if (node && node.nodeType === Node.ELEMENT_NODE) return node;
      }
    }
    return e.target && e.target.nodeType === Node.ELEMENT_NODE ? e.target : null;
  }

  function update(e) {
    // Queue one paint per frame
    pending = e;
    if (raf) return;
    raf = requestAnimationFrame(() => {
      raf = null;
      const evt = pending;
      pending = null;

      const el = findElementFromEvent(evt);
      if (!el) return;

      // Don’t label itself (should be ignored thanks to pointer-events:none, but be safe)
      if (el === label) return;

      const tag = (el.tagName || '').toLowerCase();
      if (!tag) return;

      if (tag !== lastTag) {
        label.textContent = `<${tag}>`;
        lastTag = tag;
      }

      // Position near cursor, then keep within viewport
      const padding = 8;      // gap from cursor
      const offsetX = 12, offsetY = 14;

      // Place roughly, make visible to measure
      label.classList.add('visible');
      const { innerWidth: vw, innerHeight: vh } = window;
      const rect = label.getBoundingClientRect();

      let x = evt.clientX + offsetX;
      let y = evt.clientY + offsetY;

      // Flip horizontally if overflowing
      if (x + rect.width + padding > vw) {
        x = evt.clientX - rect.width - offsetX;
      }
      // Flip vertically if overflowing
      if (y + rect.height + padding > vh) {
        y = evt.clientY - rect.height - offsetY;
      }

      // Clamp just in case
      x = clamp(x, 4, vw - rect.width - 4);
      y = clamp(y, 4, vh - rect.height - 4);

      // Use transform so layout thrash is minimal
      label.style.transform = `translate(${Math.round(x)}px, ${Math.round(y)}px)`;
    });
  }

  // Hide when the tab isn’t active (optional nicety)
  function onVisibility() {
    if (document.hidden) {
      label.classList.remove('visible');
    }
  }

  window.addEventListener('mousemove', update, { passive: true });
  window.addEventListener('mouseover', update, { passive: true });
  document.addEventListener('visibilitychange', onVisibility);

  // In case the page removes our node (SPA nav etc.), re-attach
  const obs = new MutationObserver(() => {
    if (!document.documentElement.contains(label)) {
      document.documentElement.appendChild(label);
    }
  });
  obs.observe(document.documentElement, { childList: true, subtree: true });
})();

